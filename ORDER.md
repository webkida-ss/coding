# 計算量

## 時間計算量 (Time Complexity)
アルゴリズムがタスクを完了するのに必要なステップ数や操作数のオーダーを示すもの。入力の大きさに対して、アルゴリズムがどれだけの時間を要するかのオーダーを示しています。例えば、リストの各要素を一度ずつ処理するアルゴリズムの時間計算量は O(n) となることが多いです（n はリストの要素数）。

主な例:
- O(1) : 定数時間。入力の大きさに関係なく、常に一定の時間で処理が完了。
- O(log n) : 対数時間。例: 二分探索。
- O(n) : 線形時間。例: 単純なループを使用してリストの要素を処理。
- O(n^2) : 二乗時間。例: 二重ループを使用してリストの要素を処理。
- O(2^n), O(n!) など: 指数時間。一般的に非常に遅いアルゴリズム。

## 空間計算量 (Space Complexity)
アルゴリズムがタスクを完了するのに必要なメモリ量のオーダーを示すもの。入力の大きさに対して、どれだけの追加のメモリ（変数、データ構造など）が必要かを示しています。

主な例:
- O(1) : 定数の空間。入力の大きさに関係なく、常に一定のメモリを使用。
- O(n) : 線形の空間。入力の大きさに比例してメモリを使用。例: n要素のリストや配列。

## O(n) 
「O(n)」は、計算機科学とアルゴリズムの分析において、アルゴリズムの実行時間やその他のリソースの使用量（たとえばメモリ）を大まかに記述するための「ビッグオー記法」と呼ばれる表現の一部です。

「O(n)」の「n」は、通常、処理されるデータの量やサイズ（たとえばリストや配列の要素数）を示します。

具体的に「O(n)」とは、アルゴリズムの実行時間やリソース使用量が入力サイズnに直接比例することを意味します。つまり、入力サイズが2倍になれば、アルゴリズムの実行時間も約2倍になると予想されることを示唆しています。

例えば、リスト内のすべての要素を1回ずつ確認するシンプルなアルゴリズムは、通常O(n)の時間複雑度を持ちます。リストに10の要素がある場合、アルゴリズムは10の操作を行い、20の要素があれば20の操作を行います。

このビッグオー記法は、アルゴリズムが大きなデータセットにどれだけ効果的に対応できるか、また異なるアルゴリズムや手法を比較する際の一つの指標として使われます。


## O(n^2) 
O(n^2) は、アルゴリズムの時間計算量を表すためのビッグオー記法の一つです。具体的には、入力サイズが n のとき、計算に要するステップ数が n の2乗に比例することを示しています。

アルゴリズムが O(n^2) の計算量を持つとは、そのアルゴリズムの実行時間が入力サイズの2乗に比例することを意味します。これは、入力サイズが大きくなるにつれてアルゴリズムの効率が著しく低下することを示しています。

例として、二重ループを使用して2つのリストのすべてのペアを比較するアルゴリズムは、通常、O(n^2) の計算量を持つと考えられます。

```
func exampleO_N2(nums []int) {
    for _, num1 := range nums {
        for _, num2 := range nums {
            // 何らかの処理
        }
    }
}
```

## O(1)
「定数時間計算量」とも呼ばれるもので、アルゴリズムの実行時間が入力サイズに関係なく一定であることを示します。言い換えれば、アルゴリズムが処理するデータのサイズや量がどれだけ大きくなっても、アルゴリズムの実行時間は変わらない、またはそれほど大きく変わらないことを意味します。

```
func getFirstElement(elements []int) int {
    return elements[0]
}
```

上記の関数は、配列の最初の要素を返すだけなので、配列のサイズが10であろうと、10000であろうと、実行時間はほぼ同じです。

計算量のO(1)は非常に効率的であると見なされます。しかし、O(1)が「高速」という意味ではないことに注意が必要です。O(1)は実行時間が一定であることを意味するだけで、その「一定の時間」が長いか短いかは別の問題です。

また、空間計算量の文脈では、O(1)はアルゴリズムが固定の追加メモリしか使用しないことを意味します。


## O(log n) 
log は対数を示しており、通常は2を底とする二進対数を意味します。
O(logn) という計算量は、アルゴリズムが問題のサイズ n に対して対数的に時間がかかることを意味します。具体的には、問題のサイズが2倍になるたびに、必要なステップ数が1ステップ増えることを示しています。

例:
二分探索は、ソートされたリストの中央の要素を確認し、探している要素が中央よりも左側または右側にあるかを判断して探索範囲を半分に絞り込みます。そのため、リストの長さが2倍になると、最悪の場合でも1回の追加の比較だけが必要となります。
このような性質から、O(logn) のアルゴリズムは非常に効率的であると言えます。特に大きなデータセットに対しては、リニアタイムのアルゴリズム O(n) よりもはるかに高速に動作します。

# データ構造
- データ：ノードが持つ実際の情報や値。
- 参照：次のノードや子ノードへのポインタやリンク。

## ノードについて

### 連結リストのノード
連結リストにおけるノードは、データ部と次のノードへの参照（ポインタ）から構成されます。例えば、Go言語での単純なノードの定義は以下のようになります
```
type ListNode struct {
    Val  int       // ノードが持つデータ
    Next *ListNode // 次のノードへの参照
}
```

### 二分木のノード
二分木におけるノードは、データ部と2つの子ノードへの参照（左と右）から構成されます。
```
type TreeNode struct {
    Val   int
    Left  *TreeNode // 左の子ノードへの参照
    Right *TreeNode // 右の子ノードへの参照
}
```


## Linked List（リンクドリスト、連結リスト）
スタック、キュー、ハッシュテーブルの実装などに利用されます。

### ノードとポインタによる構造
リンクドリストはノード（データを格納する部分）とポインタ（次のノードへの参照を格納する部分）で構成されています。各ノードは自身のデータと次のノードへのリンク（ポインタ）を持っています。

### 動的なデータ構造
リンクドリストは動的なデータ構造で、実行時にサイズを変更することが可能です。新しいノードの追加や既存のノードの削除が容易に行えます。

### メモリ効率
リンクドリストは連続したメモリ領域を必要としないため、メモリの効率的な利用が可能です。

### 挿入と削除の効率
リンクドリストでは、ノードの挿入と削除が効率的に行えます。ただし、特定のノードを検索するためにはリスト全体を通過する必要があります。

### 種類
リンクドリストにはいくつかの種類があります。単方向リンクドリスト（Singly Linked List）、双方向リンクドリスト（Doubly Linked List）、循環リンクドリスト（Circular Linked List）などがあります。

#### ノードの挿入と削除が効率的に行える理由
ノード間のリンク（ポインタ）を更新することで操作が可能だからです。  
挿入の場合、新しいノードをリンクドリストに追加するには、新しいノードのポインタを次のノードにリンクさせ、前のノードのポインタを新しいノードにリンクさせるだけです。これにより、新しいノードがリンクドリストに挿入されます。  
削除の場合も同様で、ノードを削除するには、削除するノードの前のノードのポインタを削除するノードの次のノードにリンクさせるだけです。これにより、削除するノードがリンクドリストから取り除かれます。  
しかし、これらの操作を行う前に、挿入または削除する位置を見つける必要があります。リンクドリストでは、特定の位置を見つけるためにはリストの先頭からその位置まで順にたどる必要があります。これはリンクドリストが連続したメモリ領域に格納されていないため、ランダムアクセスができないからです。そのため、特定のノードを検索する際の時間複雑度はO(n)となります。


#### 配列との比較
配列はメモリ上で連続的に配置されるため、配列の任意の要素に対して直接アクセスすることが可能です。これは、配列の各要素がメモリ上で一定の距離（通常は要素のサイズに等しい）だけ離れて配置されているためです。  
配列のインデックスは、基本的には配列の先頭からのオフセット（距離）を表しています。したがって、配列の任意の要素にアクセスするためには、その要素のインデックスを知っていれば、直接そのメモリアドレスにジャンプすることができます。これは定数時間、つまりO(1)の操作です。  
例えば、整数の配列があり、各整数が4バイトのメモリを占有しているとします。この配列の先頭アドレスが1000で、ある要素にアクセスしたいとします。その要素のインデックスが3であれば、その要素のメモリアドレスは 1000 + (3 * 4) = 1012 となります。この計算は定数時間で行うことができ、したがって任意の要素へのアクセスも定数時間で可能となります。

##### まとめ
- リンクドリスト：挿入と削除が効率的に行えるが、特定のノードを検索する際にはリスト全体を通過する必要がある。
- 配列：特定の要素へのアクセスが効率的だが、挿入と削除が効率的に行えない（全体をずらすから）。


## スタック：LIFO

スタックは、データ構造の1つで、要素を追加したり（プッシュ）、最後に追加した要素を取り出したり（ポップ）する際の特定の順序（Last In, First Out: LIFO）を持ちます。このLIFOの性質は、最後にプッシュされた要素が最初にポップされることを意味します。

スタックの挙動を簡単に例えるなら、皿を積み上げることと似ています。新しい皿を上に積み上げ（プッシュ）し、取る時は一番上の皿から取る（ポップ）のと同じです。

スタックの主な操作：
- Push: スタックのトップに新しい要素を追加する。
- Pop: スタックのトップから要素を取り出し、その要素を返す。取り出した要素はスタックから削除される。
- Top/Peek: スタックのトップの要素を取得するが、要素はスタックから削除されない。
- IsEmpty: スタックが空であるかどうかを確認する。

スタックは、再帰、逆ポーランド記法の計算、文書の履歴の管理（戻る/進むボタン）、括弧のバリデーションなど、多くの計算タスクで使用されます。スタックは配列やリンクリストで簡単に実装することができます。多くのプログラミング言語には、スタックを操作するための標準ライブラリが含まれています。


## キュー：FIFO
キューは、データ構造の1つで、スタックとは異なる挿入と取り出しの順序、すなわちFirst In, First Out (FIFO) の性質を持っています。このFIFOの性質は、最初に挿入された要素が最初に取り出されることを意味します。

キューの動作を例えるなら、人々が列をなして待つ、例えば銀行の窓口やレジの行列のようなものです。最初に列に並んだ人（要素）が最初に対応を受ける（取り出される）のと同じです。

キューの主な操作：

- Enqueue: キューの末尾に新しい要素を追加する。
- Dequeue: キューの先頭の要素を取り出し、その要素を返す。取り出した要素はキューから削除される。
- Front/Peek: キューの先頭の要素を参照するが、要素はキューから削除されない。
- IsEmpty: キューが空であるかどうかを確認する。
- Size: キューに含まれる要素の数を返す。

キューは、タスクのスケジューリング、データのバッファリング、幅優先探索など、多くのアプリケーションやアルゴリズムで利用されます。

実装に関しては、キューは配列やリンクリストを使用して実装できますが、効率的なキューの操作のためには、循環バッファやダブルエンドキュー（Deque）などの特定のデータ構造が使用されることもあります。

また、多くのプログラミング言語には、キューを操作するための標準ライブラリや関連する関数が提供されています。

## ヒープ

## ハッシュテーブル
# クイックソート
https://webpia.jp/quick_sort/#index_id2


## メリット

### 高速
平均計算時間が O(n log n) であり、大量のデータを扱う際に高速に動作します。

### インプレースソート
追加のメモリをほとんど必要とせず、ソートを行う配列内で要素の交換が行われます。

### キャッシュ効率が良い
近い要素間での操作が多いため、CPUキャッシュを効率的に使用することができます。

### 平均的なケースで効率的
他の O(n log n) ソートアルゴリズムと比較して、平均的なケースではより高速です。


## デメリット

### 最悪計算時間が O(n^2)
ピボットの選択が不適切な場合、計算時間が O(n^2) になることがあります。

### 不安定ソート
同じ値の要素の相対的な順序がソート後に変わる可能性があります。

### 最悪のケースを避けるための工夫が必要
ピボット選択やアルゴリズムの改良（例: ランダム化クイックソート、三つ分割クイックソート）が
必要です。

### 再帰の深さに注意
非常に不均衡な分割が続くと、再帰の深さが大きくなり、スタックオーバーフローを引き起こす可能性があります。


## ステップバイステップ

### ピボットの選択
- 配列からピボットとなる要素を選びます。ピボットの選び方は様々ですが、一般的には配列の最後の要素、最初の要素、中央の要素、またはランダムな要素が使われます。

### 分割 (Partitioning)
- 配列を二つのパーティションに分けます。一つはピボットより小さい全ての要素を含み、もう一つはピボットより大きい全ての要素を含みます。
- 分割のプロセス中に、ピボットより小さい要素をピボットの左側に、ピボットより大きい要素を右側に移動します。

### 再帰 (Recursion)
- ピボットを除いた左右のサブ配列に対して、再帰的にクイックソートを適用します。
- このステップは、サブ配列のサイズが1以下になるまで、つまりそれ以上分割できないまで繰り返されます。

### 終了 (Termination)
- 再帰が終了すると、配列はソートされた状態になります。クイックソートはインプレースアルゴリズムなので、元の配列が直接変更されます。


## ピボットの選択
配列の中央の要素

- 単純さ: 中央の要素を選ぶのは理解しやすく、実装が簡単です。
- 平均的なパフォーマンス: 事前に配列の分布がわからない場合、中央の要素を選ぶことで、平均的なケースにおいては良いパフォーマンスを期待できます。
- 最悪ケースの回避: 既にソートされた配列や逆順にソートされた配列のような特定のケースで最悪のパフォーマンス（O(n^2)）を避けるために、中央の値を選ぶことが有効です。
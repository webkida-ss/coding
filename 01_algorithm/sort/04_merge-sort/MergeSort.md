# マージソート
https://www.youtube.com/watch?v=FLSNQo793es

## 問題の内容
あなたは、整数の配列をマージソートを使ってソートするアルゴリズムを実装しています。マージソートの基本的なプロセスを説明し、このアルゴリズムがどのようにして配列の要素を効率的にソートするかを説明してください。また、マージソートの時間計算量と空間計算量についても触れてください。


## メリット

### 安定性
同じ値の要素の相対的な順序が変わらないため、安定なソートが可能です。これは複数のキーでのソートや複雑なデータ構造において重要です。

#### 安定性とは
安定性は特に、複数のキーを基にソートを行う場合に重要です。たとえば、まず年齢でソートし、その後名前でソートする場合、安定なソートアルゴリズムを使うことで、最初のソート（年齢）の結果が保持されます。これにより、複数の条件を基に整理された一貫性のあるソート結果が得られるのです。  
以下の例の場合に、年齢で並び替えた後に後に名前が元の順番をキープしているのが安定。  
- (花子, 20)
- (次郎, 25)
- (太郎, 25)

### 効率的
最悪、平均、最良のケースでも、時間計算量は O(n log n) で一定です。これは多くのソートアルゴリズムの中で良好なパフォーマンスです。

### 大規模なデータに適している
データが大きい場合や外部ソートが必要な場合（例：ディスク上のデータをソートする場合）に適しています。サブ配列を個別にソートし、それらを結合する方法は大規模なデータセットに適しています。  
※ ゴルーチンで並列処理した前提  
※ 外部ソート： データがメモリに収まらない場合に、ディスクに一時的に保存しながらするソート

### 並列処理が可能
マージソートは分割統治法を使用するため、サブ配列のソートを並列で行うことが可能です。これにより、マルチコアプロセッサを利用した高速化が可能です。

## デメリット

### 空間計算量
マージソートは追加の配列を必要とするため、空間計算量が O(n) になります。これは、インプレースソート（例：クイックソート）と比較して不利です。

### 遅い小規模配列の処理
小さいデータセットの場合、マージソートは他の簡単なソートアルゴリズム（例：挿入ソート）よりも遅いことがあります。そのため、小規模データには他のアルゴリズムが適していることがあります。

- 分割とマージのオーバーヘッド
- 再帰呼び出しのコスト
- 効率的なアルゴリズムの選択：挿入ソートなど

### 複雑性
実装が比較的複雑であり、特にリンクリストなどのデータ構造に対するマージ操作は直感的でない場合があります。

### 非適応性
すでに部分的にソートされているデータに対しても、マージソートは全体を通して同様の手順を行います。そのため、部分的にソートされたデータに対しては、適応性のあるアルゴリズム（例：挿入ソート）の方が効率的な場合があります。


## 解答のヒント

### 基底ケース
配列のサイズが1の場合、配列は既にソートされているため、何もする必要がありません。

### ステップバイステップ

#### ステップ 1: 分割 (Divide)
マージソートは分割統治法に基づいています。最初のステップは、配列を半分のサイズの二つのサブ配列に分割することです。

```
mid := len(arr) / 2
left := make([]int, mid)
right := make([]int, len(arr)-mid)

copy(left, arr[:mid])
copy(right, arr[mid:])
```

#### ステップ 2: 再帰的ソート (Conquer)
次に、これらのサブ配列を再帰的にソートします。このステップでは、配列が1つの要素になるまで再帰的に分割を続け、各サブ配列をソートします。

```
mergeSort(left)
mergeSort(right)
```

#### ステップ 3: マージ (Combine)
分割された配列がソートされた後、それらを結合して一つのソートされた配列にします。このプロセスは「マージ」です。

```
func merge(arr, left, right []int) {
    i, j, k := 0, 0, 0

    while i < len(left) && j < len(right) {
        if left[i] < right[j] {
            arr[k] = left[i]
            i++
        } else {
            arr[k] = right[j]
            j++
        }
        k++
    }

    // 残りの要素をコピー
    for i < len(left) {
        arr[k] = left[i]
        i++
        k++
    }

    for j < len(right) {
        arr[k] = right[j]
        j++
        k++
    }
}
```

## マージ操作における安定性
### 要素の比較
マージ操作では、二つのサブ配列から要素を順番に比較し、より小さい要素を新しい配列に配置します。同じ値を持つ要素が存在する場合、マージソートは最初に出現する要素（つまり元の配列で前にある要素）を新しい配列に先に追加します。

### 元の順序の維持
このようにして、同じ値を持つ要素の相対的な順序は元の配列と同じに保たれます。例えば、二つの同じ値を持つ要素が元の配列で左側のサブ配列と右側のサブ配列にそれぞれ存在する場合、左側のサブ配列の要素が先に新しい配列に追加され、元の順序が維持されます。
# Remove Duplicates from Sorted Array
https://leetcode.com/problems/remove-duplicates-from-sorted-array/

## 解説
In Placeなので配列の状態もチェックされる。

### アルゴリズム
- nums 配列の長さが 0 または 1 の場合、すでにユニークな要素のみを含んでいるので、配列の長さをそのまま返す。
- ポインタやインデックス i を使って配列を走査する。
- 別のポインタやインデックス index を使用して、ユニークな要素を挿入する場所を追跡する。
- i を増やしていき、nums[i] が nums[i-1] と異なる場合、nums[index] に nums[i] の値を設定し、index を1増やす。

### 計算量
#### 時間計算量: O(n)
配列 nums の各要素は1回だけ調査されるため、時間計算量は O(n) です（n は配列 nums の長さ）。

#### 空間計算量: O(1)
固定量の変数（2つのポインタやインデックス）のみを使用しているので、追加の空間計算量は O(1) です。これはインプレースの操作であるため、元の配列の外部に新しい配列やデータ構造を作成することはありません。

このアルゴリズムは、2つのポインタ（またはインデックス）を使用して配列を1回走査するだけなので、非常に効率的です。重複する要素が隣接しているという配列のソート済みの性質を利用して、ユニークな要素のみを追跡・移動することができます。

## In-place algorithm
データを変換またはソートする際に、入力として与えられたデータ構造の内部で直接操作を行い、追加のメモリ領域を使用せず（または非常に少量の追加メモリを使用して）その操作を完了するアルゴリズムを指します。

インプレースアルゴリズムの利点は、追加のメモリ消費が少ないことから、メモリ制約が厳しい環境での利用に適しています。一方、入力データを直接変更するため、操作前のデータが失われることがあるので、注意が必要です。

### 追加のメモリ使用量が小さい
インプレースアルゴリズムは追加のメモリをほとんどまたはまったく使用しない。通常は固定量の追加メモリ（たとえば数値やポインタを格納するための少量の変数）を使用します。

### 入力データの上書き
インプレースアルゴリズムは、結果を保存するために入力データを直接変更（上書き）します。

### 実際の利用
インプレースソート（例: バブルソート、挿入ソート、クイックソートの一部の実装）や、配列やリスト内の要素の操作（例: 上記の「Remove Duplicates from Sorted Array」の問題）など、多くのアルゴリズムでインプレースの操作が用いられます。

## その他
### Ascending order
```
[1, 2, 3, 4, 5]
```
## Non-decreasing order 
重複を許容
```
[1, 2, 2, 3, 4, 4, 4, 5]
```

### Relative order
考えられる配列：[a, b, c, d, e]

もし、この配列からbとdを取り除いた場合、残りの要素a、c、およびeの相対的な順序は変わりません。つまり、aはcの前にあり、cはeの前にあります。このように、元の順序の関係性が維持されている状態を、"relative order"が保持されていると言います。

# Merge Two Sorted Lists
https://leetcode.com/problems/merge-two-sorted-lists/


☆ むずい！要復習！

## 解説
あなたは2つのソート済みの連結リストが与えられており、これらをマージして1つのソート済みの連結リストにする必要があります。

この問題の主要な考え方は、2つのリストのノードを比較しながら新しいリストを作成することです。しかし、新しいノードを作成する代わりに、既存のノードの参照を使用してリストを再構築します。

アルゴリズムのステップは以下の通りです：

- ダミーヘッド（仮の先頭ノード）を作成します。
- 現在のノード（current）をダミーヘッドに設定します。
- list1とlist2のノードが存在する限り、それらのノードの値を比較します。
- より小さい値のノードを新しいリストに追加し、そのリストのノードへの参照を進めます。
- 1つのリストが終了すると、もう1つのリストの残りのノードを新しいリストに追加します。
- ダミーヘッドの次のノード（dummy.Next）がマージされたリストの実際の先頭です。

## 計算量
### 時間計算量: O(m + n) 
ここで、m と n はそれぞれ list1 と list2 の長さです。最悪の場合、2つのリストのすべてのノードを走査する必要があります。

### 空間計算量: O(1) 
ダミーヘッドおよび数個の変数しか使用していないため、定数空間を使用しています。新しいノードを作成することはありません。
このアルゴリズムは効率的に2つのリストをマージすることができ、リストのサイズが大きくなっても性能が維持されます。

## ダミーヘッド/ダミーノード
リストの最初の要素の前に仮のヘッドノードを置くことを意味します。

### 統一性
ダミーヘッドを使用すると、リストの最初のノードを特別扱いする必要がなくなり、コードがシンプルになります。たとえば、新しいノードをリストの先頭に挿入する場合、通常は特別な処理が必要ですが、ダミーヘッドがあると、先頭への挿入もリストの中間への挿入と同じように扱えます。
### コードの簡略化
リスト操作のアルゴリズムで条件分岐を減らすことができます。これは特に、マージソートや前述の2つのソート済みリストのマージのような操作で役立ちます。

### ダミーヘッドの使用例
連結リストでのマージ操作において、結果リストの先頭がどのノードになるかは動的に変わる可能性があります。ダミーヘッドを使用すると、結果リストの実際の先頭ノードを後から簡単に特定できるようになります。操作が完了したら、ダミーヘッドの次のノードが結果リストの実際の先頭となります。

注意点として、ダミーヘッドは実際のデータを持たない仮のノードであり、最終的な操作結果には含めません。

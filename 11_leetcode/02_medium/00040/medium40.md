# Combination Sum II
https://leetcode.com/problems/combination-sum-ii/


## 解説
この問題はバックトラッキング（深さ優先探索）を用いて解くことができます。以下にそのポイントを解説します。

### ソート
candidatesをソートすることで、探索中に現在の合計が目標値を超えた場合、それ以上の探索を打ち切ることができます。また、ソートにより同じ値を持つ要素が隣接するため、重複する組み合わせを避けることができます。

### バックトラッキング（深さ優先探索）
dfs関数は再帰的に呼び出され、各ステップで候補の数値を選択します。選択した数値をpathに追加し、目標値からその数値を引きます。新しい目標値が0になった場合、pathは解の一部となります。

### 重複の排除
同じ深さで同じ値を持つ要素を選択すると、同じ組み合わせが生成される可能性があります。これを避けるために、同じ深さで同じ値を持つ要素が前に選択されていた場合、それをスキップします。

### データの流れ

このコードのデータの流れを具体的に示します。以下の例では、candidatesが[10, 1, 2, 7, 6, 1, 5]で、targetが8とします。

1. combinationSum2関数が呼び出され、candidatesがソートされます。ソート後のcandidatesは[1, 1, 2, 5, 6, 7, 10]となります。

2. dfs関数が初めて呼び出されます。この時、numsは[1, 1, 2, 5, 6, 7, 10]、targetは8、idxは0、pathは[]、resは[][]int{}です。

3. dfs関数内のforループが開始されます。最初のイテレーションでは、iは0なので、nums[i]は1です。target - nums[i]は8 - 1 = 7なので、0より大きいです。また、i > idx && nums[i] == nums[i-1]はfalseなので、次のdfs関数が呼び出されます。この時、numsは[1, 1, 2, 5, 6, 7, 10]、targetは7、idxは1、pathは[1]、resは[][]int{}です。

4. 2と3のステップが再帰的に続きます。pathが[1, 1, 2, 5]となった時、targetは-1となります。これは0より小さいので、このパスは解になり得ないため、このパスを捨てて（バックトラックして）次の選択肢に進みます。

5. 最終的に、全ての可能なパスが探索され、targetが0となるパスが解としてresに追加されます。この例では、resは[[1 1 6] [1 2 5] [1 7] [1 2 5]]となります。

6. combinationSum2関数がresを返します。この例では、[[1 1 6] [1 2 5] [1 7] [1 2 5]]が返されます。

## 計算量

### 時間計算量: O(2^n n log n)
nはcandidatesの長さです。2^nはすべての部分集合を生成するための計算量で、n log nはソートの計算量です。

### 空間計算量: O(n)
これは再帰の深さ（つまり、pathの最大長）に対応します。
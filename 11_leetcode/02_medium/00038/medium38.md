# Count and Say
https://leetcode.com/problems/count-and-say/

## 解説
文字列の操作と再帰的な思考が必要な問題です。主なポイントは以下の通りです。

### 再帰: countAndSay(n)はcountAndSay(n-1)の結果に依存します。これは再帰的なパターンで、基底ケースはn=1のときです。このケースでは、結果は常に"1"です。

### 文字列操作: countAndSay(n)の結果を得るためには、countAndSay(n-1)の結果をスキャンし、同じ数字が連続している部分を見つけ、その数とその数字を新しい文字列に追加する必要があります。これは文字列の操作とカウントの管理を必要とします。

### カウントと結合: 同じ数字が連続している部分を見つけたら、その数（カウント）とその数字を新しい文字列に追加します。これは、数字のカウントとその数字自体を文字列に変換し、それらを結合する操作を必要とします。

これらのポイントを理解し、適切にコードに落とし込むことで、この問題を解くことができます。

### 参考
- n = 1のとき、出力は"1"です。
- n = 2のとき、前の項目"1"を見て、"1"が1つあるので出力は"11"になります。
- n = 3のとき、前の項目"11"を見て、"1"が2つあるので出力は"21"になります。
- n = 4のとき、前の項目"21"を見て、"2"が1つと"1"が1つあるので出力は"1211"になります。
- n = 5のとき、前の項目"1211"を見て、"1"が1つ、"2"が1つ、"1"が2つあるので出力は"111221"になります。
- n = 6のとき、前の項目"111221"を見て、"1"が3つ、"2"が2つ、"1"が1つあるので出力は"312211"になります。


## 計算量

### 時間計算量: O(NM)
Nは入力の整数で、MはN番目の項目の長さです。再帰的な関数がN回呼び出され、各呼び出しで前の項目をスキャンするため、時間計算量はO(NM)となります。

### 空間計算量: O(M)
MはN番目の項目の長さです。再帰的な関数呼び出しのスタックと新しい文字列を保存するためのスペースが必要で、これらは最大でMに比例します。したがって、空間計算量はO(M)となります。
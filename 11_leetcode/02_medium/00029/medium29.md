# Divide Two Integers
https://leetcode.com/problems/divide-two-integers/

## 解説

### 符号の決定
まず、結果が正か負かを決定します。これは、被除数と除数の符号を比較することで行います。

### 絶対値の取得
次に、被除数と除数の絶対値を取得します。これにより、負の数に対する操作を避けることができます。

### ビットシフトによる除算
ビットシフト演算子を使用して除算を行います。被除数が除数以上である限り、除数を左にシフト（つまり、2倍）します。これにより、除数が被除数を超えるまでの「倍数」を見つけることができます。

### 商の計算
最後に、被除数から見つけた「倍数」を引き、商に加算します。これを被除数が除数未満になるまで繰り返します。

### 符号の適用
最後に、最初に決定した符号を商に適用します。

### オーバーフローの処理
if dividend == -1<<31 && divisor == -1 の条件は、被除数が最小値（-2147483648）で、除数が-1の場合をチェックしています。この場合、理論的には結果は2147483648になりますが、これはGoの int 型で表現できる最大値を超えています。したがって、この特定のケースでは、オーバーフローを防ぐために最大値 1<<31 - 1（つまり、2147483647）を直接返します。

### 2,3,4倍ではなく2のn乗でチェック
ビットシフト演算子を使用して定数倍ではなく2のn乗でチェックする主なメリットは、計算速度の向上と効率性です。  
ビットシフト演算子は、CPUレベルで非常に高速に実行されます。したがって、2のn乗でチェックすることは、乗算や除算を使用するよりも高速で効率的です。  
また、ビットシフトを使用すると、除数を2のn乗で増やすことができます。これにより、被除数を迅速に削減し、商を迅速に計算することができます。これは、特に被除数が非常に大きい場合に有効です。  
したがって、ビットシフト演算子を使用して2のn乗でチェックすることは、計算速度の向上と効率性の向上に寄与します。  
このアプローチは、ビットシフト演算子を使用して乗算と除算を模倣することにより、乗算、除算、mod演算子を使用せずに除算を行うことができます。

## 計算量

### 時間計算量: O(log(n))
ビットシフトによる除算の部分で、被除数が除数以上である限り、除数を左にシフトします。これは最大でlog(n)回行われます。したがって、時間計算量はO(log(n))です。

### 空間計算量: O(1)
このアルゴリズムでは、除数、被除数、商、一時的な変数など、定数個の変数しか使用していません。したがって、空間計算量はO(1)です。

## 当中経過
dividend = 10、divisor = 3の場合の途中経過を以下に示します。

1. 最初に、符号を決定します。両方とも正なので、結果も正になります。

2. 次に、dividendとdivisorの絶対値を取得しますが、既に両方とも正なので、値は変わりません。したがって、dividend = 10、divisor = 3のままです。

3. quotient（商）を0で初期化します。

4. dividendがdivisor以上である限り、以下の操作を行います：

- tempとmをdivisorと1で初期化します。

- temp << 1がdividend以下である限り、以下の操作を行います：

- tempとmを左に1ビットシフトします。これは、それぞれの値を2倍にします。

- 最初のループでは、temp = 3 << 1 = 6、m = 1 << 1 = 2になります。

- 2回目のループでは、temp = 6 << 1 = 12がdividend = 10を超えるため、ループは終了します。

- dividendからtempを引き、quotientにmを加算します。これにより、dividend = 10 - 6 = 4、quotient = 0 + 2 = 2になります。

5. dividend = 4が再びdivisor = 3以上なので、上記のステップを繰り返します。この結果、dividend = 4 - 3 = 1、quotient = 2 + 1 = 3になります。

6. これ以上dividendがdivisor以上にならないため、ループは終了します。

7. 最後に、最初に決定した符号（この場合は正）を商に適用します。したがって、最終的な結果は3になります。

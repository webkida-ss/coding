# Count and Say
https://leetcode.com/problems/count-and-say/

※ 難しい

## 解説

### 再起とバックトラッキング
再帰を使用して、候補の各要素を選択し、それが目標値に達するかどうかを確認します。目標値に達しない場合、同じ要素を再度選択するか、次の要素に進みます。目標値を超えた場合、その組み合わせは無効となり、バックトラック（戻る）します。

### 無限に同じ数を選択可能
同じ数を何度でも選択できるため、同じ要素を再度選択することを許可する必要があります。これは、再帰関数を呼び出すときに、次のインデックスではなく現在のインデックスを渡すことで実現します。

### データの流れ
candidates = [2, 3, 6, 7] と target = 7 の場合の具体的な処理の流れを説明します。

1. 最初に combinationSum 関数が呼び出され、backtrack 関数が初めて呼び出されます。この時点で current は空配列、index は0、target は7です。  
2. backtrack 関数内のforループが始まり、candidates の最初の要素 2 が current 配列に追加されます。その後、backtrack 関数が再帰的に呼び出され、target から 2 を引いた値 5 が新たな target として渡されます。  
3. 再帰的に呼び出された backtrack 関数でも同様にforループが始まり、再度 2 が current 配列に追加されます。target は 5 - 2 = 3 となります。  
4. このプロセスが続き、current 配列が [2, 2, 2, 1] となった時、target は 0 となります。これは目標値に達したことを意味し、current 配列が結果に追加されます。  
5. 次にバックトラッキングが行われ、最後に追加された 1 が current 配列から削除されます。そして、次の候補 3 が試されます。  
6. このプロセスが全ての候補を試すまで続きます。全ての組み合わせが試され、目標値に達するものが結果に追加されます。
このように、再帰とバックトラッキングを使用して全ての可能な組み合わせを試し、目標値に達するものを見つけることができます。

### バックトラッキング（Backtracking）
問題を解くための一般的なアルゴリズムで、全ての可能な解を探索します。これは、深さ優先探索の一種で、解の候補を一つずつ試し、その候補が問題の解にならないことが確定した場合には、その候補を「バックトラック」（取り消し）します。


## 計算量

### 時間計算量: O(N^target)
全ての可能な組み合わせを探索する必要があるため、時間複雑度はO(N^target)となります。ここで、Nは候補の数、targetは目標値です。

### 空間計算量: O(target)
再帰の深さが最大でtargetになるためです。